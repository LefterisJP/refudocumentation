#+TITLE: Refu language specification
#+AUTHOR: Lefteris Karapetsas

* Introduction
This is currently a work in progress. Nothing is final, nor decided but the purpose
of this document is to gather everything in one place so that the formal spec of the
language slowly takes shape.
* Built-in data types
** Specification
The following data types are built-in. Some of them correspond to the data types
defined by the C99 standard in =<stdint.h>= but they follow the same naming
scheme as in rust.

- *Unsigned numbers*
  + =uint=: compiler will decide the size depending on context
  + =u8=: 8 bit unsigned integer, corresponding to =uint8_t=
  + =u16=: 16 bit unsigned integer, corresponding to =uint16_t=
  + =u32=: 32 bit unsigned integer, corresponding to =uint32_t=
  + =u64=: 64 bit unsigned integer, corresponding to =uint64_t=

- *Signed numbers*
  + =int=: compiler will decide the size depending on context
  + =i8=: 8 bit signed integer, corresponding to =int8_t=
  + =i16=: 16 bit signed integer, corresponding to =int16_t=
  + =i32=: 32 bit signed integer, corresponding to =int32_t=
  + =i64=: 64 bit signed integer, corresponding to =int64_t=

- *Real numbers*
  + =f32=: corresponds to binary32, single precision floating point, as
    defined by [[http://en.wikipedia.org/wiki/IEEE_754-2008][IEE 754-2008]]
  + =f64=: corresponds to binary64, double precision floating point, as
    defined by [[http://en.wikipedia.org/wiki/IEEE_754-2008][IEE 754-2008]]

- *Strings*
  + =string=: UTF-8 encoded unicode string.
  + =string8=: Ascii encoded string

- *Other*
  + =bool=: A boolean true or false value
  + =nil=: the unit type, also known as NULL
** Thoughts                                                       :noexport:
Maybe add f16 and f128 in the future?

* Algebraic Data Types
** Specification
More complex data types can be defined by the user as Algrebraic data types. This is
achieved with the =type= keyword.

#+BEGIN_SRC refu
type person {
    name:string ,age:int |
    name:string, age:int, surname:string
}

type list {
     nil | (load:int, tail:uptr<list>)
}

type foo {
a:int,
b:(string|float)
}

type foo {
a:int,
b:(string | (i:int, f:float))
}
#+END_SRC

Above we have the definition of a person and a list. A person has a name
and an age and optionally a surname. And a list is either empty (denoted
by the =nil= keyword or it has a load of an int and a tail which is another
list.

In order to construct an instance of a data type you have to use one of its
constructors. A constructor of an object is simply defined as any of its 
sum type operands.
#+NAME Constructing an instance of a data type
#+BEGIN_SRC refu
a:person = person("steven", 23)
b:person = person("celina", 22, "wojtowicz")
#+END_SRC

As can be seen below for ease of use arguments can also be given to a
constructor as keyword arguments. If one keyword argument is passed to a
constructor then all arguments should be keyword arguments. Finally when
passing keyword arguments the order of the arguments does not matter as 
opposed to when calling a constructor normally.

#+NAME: Constructing an instance of a data type with keyword arguments
#+BEGIN_SRC refu
a:person = person(name="steven", age=23)
b:person = person(name="celina", surname="wojtowicz", age=23)
#+END_SRC

As we saw in the very beginning data types can also be recursive. This is
how we can define collections in Refu. But how do you construct a collection?
#+NAME: Constructing an instance of a recursive data type
#+BEGIN_SRC refu
a:list = nil
b:list = list(1, 2, 3, 4, 5)
c:list = list(1, list( 2, list(3, list(4, list(5, nil)))))
#+END_SRC

In the above examples list =b= and list =c= are equal. The canonical way to
define a list would be exactly like list =c= is defined, having /1/ as its
first element and using nil after /5/ to denote the list's end.

As we can see above to construct a recursive data type we still use a 
constructor but we can take advantage of the fact that the type is recursive
in order to construct it.

In the case of =b='s construction Refu knows that a list's constructor can
only accept an int and a next list pointer. Using that knowledge it can 
expand the =list(1, 2, 3, 4, 5)= to =list(1, list(2, list(3, list(4, list(5, nil)))))=.

Same thing can work for more complex recursive data types such as a binary
tree. Look below for an example.
#+BEGIN_SRC refu
type binary_tree {
nil | load:int, left:uptr<binary_tree>, right:uptr<binary_tree>
}

a:binary_tree = nil
b:binary_tree = binary_tree(8, (4, (1, 7)), (12, (10, 19)))
c:binary_tree = binary_tree(
    8, 
    binary_tree(4, 
                    binary_tree(1, nil, nil), binary_tree(7, nil, nil)),
    binary_tree(12, 
                    binary_tree(10, nil, nil), binary_tree(19, nil, nil)))
#+END_SRC

From both the binary tree and the list example we can see that Refu tries
to interpret a pointer to an object as =nil= if not existing. In addition since
the argument is known to be a pointer there is no need for the =make_ptr= type
of functions.

An algebraic data type can be considered as the equivalent of a
tagged union type in C. Refu also supports anonymous ADTs. That means,
you can encounter the ADT syntax without it having been defined.
For example, a function's argument can be an anonymous ADT.

#+NAME: Example 1
#+BEGIN_SRC refu
fn print_me(a:(string | b:int, c:int))
{
    //do some initialization stuff
    ...
    //and now do the pattern matching
    match a {
        string   => print("%s", a)
        int, int => print("%d %d", a.b, a.c)
    }
}
#+END_SRC

#+NAME: Example 2
#+BEGIN_SRC refu
fn print_me(a:string | (b:int, c:int)) -> int
_     => print("%s", a)
_, _  => print("%d %d", b, c)
#+END_SRC

#+NAME: Example 3
#+BEGIN_SRC refu
fn print_me(a:string | (b:int, c:int)) -> int
_    => {
    print("%s", a)
    print("one argument")
}
_, _ => {
    print("%d %d", b, c)
    print("two arguments")
}
#+END_SRC

In all of the above examples we have one function with an anomymous ADT.
If such a  function exists then it must have a match expression somewhere
inside its body in order to distinguish what kind of input it is having
before this input is used. The most explicit way to achieve this is to
write the match expression explicitly as in example 1. To do that we match
the keyword fn inside the function's body against the various cases.

In another case if the function body consists only of different branches
depending on the input we can omit the function's body block completely
and go with the way that example 2 is defined, which resembles a lot the
way functions are defined in haskell. It is just syntactic sugar for
achieving the same thing as in example 1. Example 3 is just an extended
version of example 2 in which each branch of the match has many statements
to execute.

** Recursive ADTs considerations
Recursive data types such as the list or the binary_tree presented above
can be quite complicated but when the compiler takes mutability into account
many optimizations can be performed especially for a very simple data structure
with only one link like the list.

#+BEGIN_SRC refu
{
    const a:list = list(1, 2, 3, 4)// this is an immutable list
    b:uptr<list> = list(1, 2, 3, 4)//mutable list on the heap
}
#+END_SRC

In the above example list =a= is immutable and is allocated on the stack. As 
such the compiler can apply the following optimization to it.
#+BEGIN_SRC ditaa
/------------+
|      1     |
+------------|
|      2     |
+------------+
|      3     |
+------------|
|      4     |
+------------|
|     nil    |
+------------/
#+END_SRC
You can notice that since it's immutable and since it has only one recursion 
path it can be optimized by the compiler to be a simple array.

If on the other hand it's a mutable list like =b= then no such optimization
can be performed and it would look like this in memory:
#+BEGIN_SRC ditaa
/------------+
|      1     |
+------------|
|     next   |--+
+------------|  |
|      2     |<-+
+------------+
|     next   |--+
+------------|  |
|      3     |<-+
+------------|
|     next   |--+
+------------|  |
|      4     |<-+
+------------|
|      next  |---> nil
+------------/
#+END_SRC

Same thing could apply if we had a binary_tree data_structure but the
optimization would work only in some cases. In other cases where the
tree is not balanced and there are many leaves it would make no sense to 
try and so such a thing. This is thought in progress.

** Thoughts                                                       :noexport:
Everything should be a type defined on top of other types. This should
mimick haskell but I would like to find a nice syntax for it. I really
like the short explanation of [[http://blog.lab49.com/archives/3011][this]] blog post and could go with similar
syntax but am afraid it may become complicated. That is why I need to
think of some syntactic sugar to make it more presentable.
A feature request from steffen that he claims Haskell and other functional
languages lack is that of anonymoys types. For example in those languages
we can't have a function like =do_something(int + string)=. You would have to
define that as a separate type. In Refu we should be able to have anonymous
types like this.

Another type related feature request from Steffen is that he would like,
as a programmer, to be able to define functions that act on types and
return other types. For example a type function called vectorize that
takes a type and returns another type which is a vectorized version of
the original. Like data simple = string + int and vectorize simple would
return [string] + [int]

A very interesting [[http://paulkoerbitz.de/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html][article]] about pointers, ownership and lifetime of objects
in Rust.

Another very interesting article about types of data is [[http://tel.github.io/2014/07/23/types_of_data/][here]]. A more complete guide to 
the algebra of the algebraic data types is here. ([[http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/][Part 1]], [[http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/][Part2]], [[http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/][Part 3]])
** Implementation considerations                                  :noexport:
This ADT declaration for a list in refu (data list = 1 + int*list)
#+BEGIN_SRC refu
type list{
    nil | a:int, next:uptr<list>
}
#+END_SRC

Would generate one of the following codes in C:
#+NAME Method 1
#+BEGIN_SRC C
struct list {
      enum tag { NULL, int_by_list};
      union {
             struct {} NULL; //(whatever way that would be represented
             struct {
               int 1;
               list *2; //(whatever way that would be represented
            }
    };
};

#+END_SRC

#+NAME Method 2
#+BEGIN_SRC C
enum list_tag { LIST_TAG_NULL, LIST_TAG_CONS }
struct list {
    list_tag tag;
}
struct list_NULL {
    list type;  // type.tag = LIST_TAG_NULL
}
list_NULL list_NULL_singleton = { LIST_TAG_NULL }
struct list_CONS {
    list type; // type.tag = LIST_TAG_CONS
    int 1;
    list *2;
}
const list *constructor_list_NULL(void) {
    return (list*)&list_NULL_singleton;
}
/*
A note about the malloc here. Any kind of memory allocation scheme could and should be used.
For example there could be something like cons_alloc which would simply take blocks of conses
with different CAR size but same (pointer size) CDR
*/
const list *constructor_list_CONS(int i, list *next) {
     list_CONS *cons = malloc(...);
     cons.type.tag = LIST_TAG_CONS;
     cons.1 = i
    cons.2 = next
    return (const list*)cons;
}
bool is_NULL(list *l)
{
     return l->type.tag == LIST_TAG_NULL;
}
bool is_CONS(list *l)
{
     return l->type.tag == LIST_TAG_CONS;
}
#+END_SRC

And as an example of a function using ADTs think of this.
#+BEGIN_SRC refu
fn len(a:list) -> int {
    len NULL = 0
    len CONS(_, rest) = 1 + len(rest)
}
#+END_SRC

This would generate the following in C.

#+BEGIN_SRC C
int len(list *l)
{
     if (l->type.tag == LIST_TAG_NULL) { return 0; }
     else {
          list *rest = ((list_CONS*)l)->2;
          return 1 + len(rest);
     }
}
#+END_SRC

* Array types
** Specification
Array types are like simple C arrays that are aware of their own size so as to
make sure there is no out of bounds access. An array is simply a contiguous 
block of memory containing values of the same type.
#+BEGIN_SRC refu
array_of_ints:int[20]
array_of_strings:string[20]
a:int = array_of_ints[5]
b = array_of_ints[5] // type deduction
c:int = array_of_ints[22] //compile error
#+END_SRC

Dynamic size arrays can also be instantiated with the built-in =make_arr(type, elements_number)=
function. An array's size in elements can be queried by =array.size=.

#+BEGIN_SRC refu
fn foo(b:ref<u8[]>) {
    b[3] = 16;
}

buffer:u8[] = make_arr(u8, 10)
foo(buffer)
printf("%d", buffer.size); // should print 10
printf("%d", buffer[3]); // should print 16
#+END_SRC

Array types are also closely related to the way the memory model of the
language works and to how a buffer can be initialized.

#+BEGIN_SRC refu
type parser {
    byte_size:int,
    string_size:int,
    buffer:byte[],
    string_buffer:string[],
}

instance std::allocator<parser> {
        fn(self:parser, a:int, s:int)
        {
           self.byte_size = a;
           self.string_size = s;
           self.buffer = make_arr(byte, self.byte_size)
           self.string_buffer = make_arr(string, self.string_size)
        }
}
// later they can both be accessed like normal arrays
p = parser(25, 10)
...
...
character = p.buffer[20]
a_string = p.string_buffer[2] //the size is checked in runtime and if there is an out of bounds access attempt an error is raised
#+END_SRC

Those buffers will be freed when the containing struct gets freed.

** Thoughts                                                       :noexport:
Thinking if the language should have arrays, maybe some form of
lists e.t.c. A nice analysis can be seen [[http://pcwalton.github.io/blog/2012/12/28/a-tour-of-vectors/][here]]

* Types and Conversions
** Specification
All elementary types can be converted from and to another type. Type conversion
can either be explicit or implicit.
** Implicit Conversion
Implicit conversion happens when you simply assign a value of one type to a value of
another type for which conversion is legal. It can also happen during almost all other
parts of the code like in a function call, in a constructor e.t.c.

The implicit conversion rules for elementary types can be seen in the following table.
| from/to | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | f32 | f64 | string | bool | nil |
| i8      | OK | WC | WC  | OK  | WC  | OK  | WC  | OK  | OK  | OK  | NO     | OK   | NO  |
| u8      | OK | OK | OK  | OK  | OK  | OK  | OK  | OK  | OK  | OK  | NO     | OK   | NO  |
| i16     | WC | WC | OK  | WC  | OK  | WC  | OK  | WC  | OK  | OK  | NO     | OK   | NO  |
| u16     | WC | WC | OK  | OK  | OK  | OK  | OK  | OK  | OK  | OK  | NO     | OK   | NO  |
| i32     | WC | WC | WC  | WC  | OK  | WC  | OK  | WC  | OK  | OK  | NO     | OK   | NO  |
| u32     | WC | WC | WC  | WC  | OK  | OK  | OK  | OK  | OK  | OK  | NO     | OK   | NO  |
| i64     | WC | WC | WC  | WC  | WC  | WC  | OK  | WC  | OK  | OK  | NO     | OK   | NO  |
| u64     | WC | WC | WC  | WC  | WC  | WC  | OK  | OK  | OK  | OK  | NO     | OK   | NO  |
| f32     | NO | NO | NO  | NO  | NO  | NO  | NO  | NO  | OK  | OK  | NO     | NO   | NO  |
| f64     | NO | NO | NO  | NO  | NO  | NO  | NO  | NO  | OK  | OK  | NO     | NO   | NO  |
| string  | NO | NO | NO  | NO  | NO  | NO  | NO  | NO  | NO  | NO  | NO     | NO   | NO  |
| bool    | OK | OK | OK  | OK  | OK  | OK  | OK  | OK  | NO  | NO  | NO     | OK   | NO  |
| nil     | NO | NO | NO  | NO  | NO  | NO  | NO  | NO  | NO  | NO  | NO     | NO   | NO  |

The values of the table are:
- OK -> conversion is allowed
- NO -> conversion is not allowed
- WC -> conversion produces a warning for a value of type and error for a constant of type
        since then we are sure that data is going to be lost. Only works for assignments now.

From the table we can understand that the general idea is that:
- All int types can be converted to each other except for:
  - signed to unsigned, which produces a warning and fails for constants
  - large  to smaller, which produces a warning and fails for constants
- All int types can be converted to booleans
- All int types can be converted to floats
- Floats can be converted to each other
- Bool can be converted to integer types

Below are some examples for assignments
#+BEGIN_SRC refu
a:u8 = 128
b:u32 = a      // implicit conversion allowed
c:u8 = b       // implicit conversion will produce a warning. Larger to smaller.
d:u8 = 65535   // implicit conversion will fail. Constant is of larger type
f:i8 = 64
e:u8 = f       // implicit conversion will produce a warning. Signed to unsigned.
g:u8 = -64     // implicit conversion will fail. Signed constant to unsigned variable.
h:i64 = true   // implicit conversion allowed. h == 1
f:bool = 2245  // implicit conversion allowed. f == true
j:bool = 0     // implicit conversion allowed. j == false
#+END_SRC

As far as binary operators are concerned the result of an operation to elementary types is valid
if one of the operands can be converted to each other. If that is the case the type of the operation
is the type of the larger type.
#+BEGIN_SRC refu
a:u64 = 653432431
b:u16 = 2324
c:f32 = 3.14
d:string = "abc"
a + b // valid u16->u64, type will be u64
b + c // valid u16->f32, type will be f32
c + d // invalid
#+END_SRC

A type can be implicitly converted to a sum type by succesfull conversion to either of its sum operands.
For example:
#+BEGIN_SRC refu
fn foo (a:u64 | b:string) { }

...

foo(45)
foo("eleos")
#+END_SRC


Only one implicit conversion is allowed per type comparison. Continuing from the above example
we can't have:
#+BEGIN_SRC refu
fn foo (a:u64 | b:string) { }

...

foo(true)
#+END_SRC
That's because this would require two different implicit conversions.
** Explicit conversions
Explicit conversions allow for quite a bit more freedom for converting between types. An explicit conversion
is achieved with a function call to the name of the type. Much like a constructor of a user defined type, which 
itself could be thought of as a sort of a type conversion.

All integer types can be converted to each other with explicit conversions, except for constants
that would obviously cause loss of data.
#+BEGIN_SRC refu
a:u64 = 542312
b:i16 = i16(a)    // valid explicit conversion, would give warning as implicit
c:u16 = u16(b)    // valid explicit conversion, would give warning as implicit
d:u8  = u8(-13)   // invalid explicit conversion, obvious loss of data
e:u8  = u8(65535) // invalid explicit conversion, obvious loss of data
#+END_SRC

Floats can be explicitly converted to ints.
#+BEGIN_SRC refu
a:f32 = 3.2313;
b:f64 = 123.231233;
c:u32 = u32(a);  // valid explicit conversion, would give warning as implicit
d:u16 = u16(b);  // valid explicit conversion, would give warning as implicit
#+END_SRC

An interesting case is explicit conversion to string. Explicit conversion to string is allowed
but only for integer, floating constant and booleans.
#+BEGIN_SRC refu
a:u32 = 2321;
b:string = string(2313)   // valid conversion
c:string = string(a)      // invalid conversion, not constant
d:string = string(23.231) // valid conversion
e:bool = (3 == 4)
e:string = string(e)      // valid conversion
#+END_SRC

* Memory Model
** Specification
The memory model of Refu is very similar to that of C++11. All non-pointer objects
 are allocated on the stack and are freed when they go out of scope.
For example:
#+BEGIN_SRC refu
{
    a:int
    s:string
} //neither a nor s will be accesible after here
#+END_SRC

To allocate memory in the heap a pointer type is used. If a pointer type gets
declared in a scope it has to be initialized. This way we can avoid dangling
pointers.

*** Unique pointers
A unique pointer, is a special generic type represented by =uptr<T>=
For example
#+BEGIN_SRC refu
type person {
    name:string,
    age:int
}

fn main()
{
    a:person = person("jerry", 22)
    b:uptr<person> = make_uptr(person("john", 15))
    c = make_uptr(person("james", 31))
    d = b
    // from here and on b can't be used
}
#+END_SRC

A unique pointer is also known as an /owned pointer/. What this means is
that the pointer is owned by the scope it is in. As an example at the above
code =b= is initialized and acquires ownership of John. Then =d= takes
ownership of john by the assignment.

Any use of b afterwards would be invalid and would raise a compiler error.
Another thing to note is that the fact that a variable is a pointer type can be
automatically deduced as is the case above with =c=. The way =b= is declared is kind of
an overkills to show this point.

An owned pointer can also appear inside a data definition. If that happens
then that means that objects of the data type own the object to which they
contain an owned pointer. 

#+BEGIN_SRC refu
type file_index {
    nil | index:uptr<something>
}
type person {
    name:string,
    age:int,
    index:uptr<file_index>
}

fn set_something(p:&person, i:uptr<file_index>)
{
    p.index = file_index
}

fn main()
{
    i:file_index = something(...)
    a:person = person("jerry", 23, nil)
    
    set_something(&a, &i);
    //from here and on i is owned by b and can't be assigned to anything
    
    b:uptr<person> = a
    //from here and on a can't be accessed
    d:person = a //illegal!
}
#+END_SRC

Noteworthy from above is how we can denote that a pointer can be pointing
to a special value that means empty as we can see from the definition of
the =file_index= object.

Another thing to note is the assignment of the object owned by =a= to =b=.
Since they are both owned pointers of an object the assignment operation
simply moves the ownership of the pointer and as such =b= can't be accessed
anymore.
*** Shared pointers
A shared pointer is a reference counted pointer and is designated by =sptr<T>=.
//TODO
*** Raw pointers
A raw pointer is a plain old C type of pointer to some memory location. It is 
denoted by =ptr<T>=
*** References
//TODO

** Thoughts                                                       :noexport:
- *Pointer Types*
Here is [[http://static.rust-lang.org/doc/master/rust.html#pointer-types][rust's pointer types page]] and a nice [[http://pcwalton.github.io/blog/2013/03/18/an-overview-of-memory-management-in-rust/][blog post]].
- *Shared pointers*
   [[http://pcwalton.github.io/blog/2013/06/02/removing-garbage-collection-from-the-rust-language/][Why]] shared pointers are removed from Rust core language and moved to std lib

* Functions
** Specification
Functions in Refu are declared just like in the Rust language. The
keyword =fn= followed by the name of the function, the arguments and
finally by an arrow pointing to the return value.  If there is no return
value then the arrow is omitted. Some examples follow:

#+BEGIN_SRC refu
fn add_two_ints(a:int, b:int) -> int
{
     return a + b
}

fn print_something()
{
     print("something")
}
#+END_SRC

Inside the function's body a =return= statement denotes the expression
that determines the return value. A function may return a value but still
need no return value if it's compact enough and has all its
functionality under a =match=, =if= or =for= expression. For example:

#+BEGIN_SRC refu
fn int_inside_range(x:int, from:int, to:int) -> bool
{
    if (x >= from && x <= to) { true} else { false}
}
#+END_SRC

In the absense of a return value the function's last expression statement
value is interpreted as the return value. For example the following function's 
return value is determined by a + 1

#+BEGIN_SRC refu
fn do_something(a:int) -> int
{
    a = a * 2
    if (a > 10) {
       a - 5
    } else {
       a - 1
    }
    a + 1
}
#+END_SRC

Moreover a function can also completely omit a body block if it has a match expression on its arguments like below:
#+BEGIN_SRC refu
fn find_length(a:~list)->int
(nil) => 0
(_, tail) => 1 + find_length(tail)
#+END_SRC
* Type Parameters
** Specification
Refu supports type parameters, which syntactically look like generics of some other programming languages. Their use will
be seen heavily in the use of typeclass below but first let's see the syntax.

#+BEGIN_SRC refu
type list<type T> {
     nil | payload:T , tail:uptr<list>
}
..
..

a:list<int> = (5, 6, 7, 8)
#+END_SRC

This would define a generic ADT list, and later the user declares a list
of ints and populates it. Same thing can be done with an ADT binary tree.

#+BEGIN_SRC refu
type binary_tree <type T> {
    nil | payload:T , left_branch:uptr<binary_tree>, right_branch:uptr<binary_tree>
}
...
...
/*
             1.0
             / \
         0.1    2.0
         /  \    / \
      0.01 0.2  1.5 3.3
*/

a:binary_tree<double> = ( 1.0, (0.1, (0.01), (0.2)),  (2.0, (1.5, 3.3)))
a:binary_tree<double> = (1.0, cons(0.1, cons(0.01, Nil), cons(0.2, Nil) ),  cons(2.0, cons(1.5, Nil), cons(3.3, Nil)))
#+END_SRC

Type paramerers can. Type parameters can be of either a concrete type as designated by =type=
or by a type of a type also known as a =kind=. We will read more about kinds in the corresponding section.

* Kinds
** Specification
Kinds are like the types of types. For example =type= is a concrete type while
 =derivative= is a kind defined as:

#+BEGIN_SRC refu
kind derivative {
   type -> type
}
#+END_SRC

which means that a type that is derived from another type is a derivative type.

For example our good old friend the list as seen below.
#+BEGIN_SRC refu
type list <type T>{
    nil | (load:int, tail:uptr<T>)
}
#+END_SRC
It's a type of kind derived because it takes a concrete type and produces another concrete type.

For a more complicated example of a kind imagine the following:
#+BEGIN_SRC C++
kind complicated {
   (type, derivative) -> type
}
#+END_SRC
This new complicated kind takes a concrete type and a type of derivative kind as defined above
and produces a concrete type. But how would an example of a type of this kind look? Look below:
#+BEGIN_SRC refu
type list_with_size <type T, derivative Y>{
    a:Y<T>, b:int
}

a:const list<int> = list(1, 2, 3)
foo:list_with_size<int, list> = list_with_size(a, 3)
#+END_SRC

If for whatever reason you may have needed to represent a list with its size as an extra type over an 
already defined list you could do it as shown above. Notice the usage of =derivative= kind as defined in
the preceding example.

* Typeclasses
** Specification
Refu relies heavily on the use of typeclasses. They are an important
way to guarantee behaviour about objects of a given type. There are quite a few builtin
typeclasses in the standard library. The concept of a typeclass is similar to that of an
interface in some other languages.
*** Simple example
Here is one example which defines the operation for the adding operator. This allows an object to define how it
shall be added. One can notice the keyword =self= which defines the object
the function will be called for and also the generic syntax of =<type T>=
since we can't know the type of the object we are adding.

#+BEGIN_SRC refu
class addition<type T> {
   fn(self:T, other:T) -> T
}

type vector {
    x:int, y:int, z:int
}

//A type would declare that it derives the typeclass
instance addition<vector> {
   fn(self:vector, other:vector) -> vector
   {
       ret:vector
       ret.x = self.x + other.x
       ret.y = self.y + other.y
       ret.z = self.z + other.z
       return ret
   }
}
#+END_SRC

So what the above code declares is that there is some type called =vector=. That type is an instance
of the addition typeclass with the given implementation. The addition typeclass like some other special
typeclasses allow for special operations. In particular it allows for overloading operator =+=. So adding
two vectors would in essence call the instance of the typeclass.
*** Advanced example
Following you will find a more complicated example of the use of typeclasses.
#+BEGIN_SRC refu
type uptr<type T> {
    nil | p:*T // using C notation for the pointer here
}

class pointers <derivative pointer_kind, type T> {
    fn assign (self:pointer_kind<T>, other:pointer_kind<T>)
    fn addressof (self:pointer_kind<T>) -> ref<T>
    fn dereference (self:pointer_kind<T>) -> T
}
#+END_SRC

In the above code example we create a class for pointer types. All pointers need two things to be defined
correctly, the kind of pointer (shared, unique, raw) and the type of the object that the pointer will point to.

Let's look below at the example of one such type, the unique pointer, which is an instance of this typeclass.
#+BEGIN_SRC refu
instance pointers<uptr, type T> {
    fn assign (self:uptr<T>, other:uptr<T>)
    {
        // implementation
    }

    fn addressof (self:uptr<T>) -> ref<T>
    {
        // implementation
    }

    fn dereference (self:uptr<T>) -> T
    {
        // implementation
    }
}
#+END_SRC

This is how you would declare an instance of a typeclass. The above code denotes that uptrs can be used with all
of the functions of the pointers typeclass, and provides their implementation. This requires though that somewhere above
the declaration of the =uptr= type should exist.

Another notation that would combine the type instantiation along with the instance of the typeclass can be seen below.
#+BEGIN_SRC refu
type uptr<type T> {
    nil | p:*T // using C notation for the pointer here
} derives pointers<uptr, T> {
    fn assign (self:uptr<T>, other:uptr<T>)
    {
        // implementation
    }

    fn addressof (self:uptr<T>) -> ref<T>
    {
        // implementation
    }

    fn dereference (self:uptr<T>) -> T
    {
        // implementation
    }
}
#+END_SRC
*** Using same function in multiple instances of different typeclasses
Imagine for a moment that we would also want to overload the =&= operator to allow for taking the address of a pointer.
That means we would want the same function to be used in the implementation of different typeclasses.
In that case we would need to have one small change in the above code.

#+BEGIN_SRC refu
class ampersand<type T> {
    fn overload(self:T) -> Any
}

fn addressof_pointers<derivative pointer_kind, type T>(self:pointer_kind<T>) -> ref<T>
{
    // implementation of getting the address of the pointer
}

instance pointers<uptr, type T> {
    fn assign (self:uptr<T>, other:uptr<T>)
    {
        // implementation
    }

    addressof = addressof_pointers<uptr, T>

    fn dereference (self:uptr<T>) -> T
    {
        // implementation
    }
}

instance ampersand<uptr<T>> {
    overload = addressof_pointers<uptr, T>
}
#+END_SRC

As can be seen above we can simply point to an external function as the implementation of a 
function for a typeclass instance.

*** Typeclass Inheritance
The use of typeclasses is extended by the possibility of inheritance between typeclasses.
#+BEGIN_SRC refu
class equality<type T> {
    fn equals(self:T, other:T) -> bool
    fn nequals(self:T, other:T) -> bool
}

class comparison<type T> extends equality{
    fn greater_than(self:T, other:T) -> bool
    fn less_than(self:T, other:T) -> bool
}

class super_comparison<type T> extends comparison{
    fn gteq(self:T, other:T) -> bool
    fn lteq(self:T, other:T) -> bool
}

//multiple inheritance
class reader <type T> {
   fn read(a:T)
}

class writer <type T> {
   fn write(a:T)
}

class io <type T> extends (reader, writer) {
    // can be empty or can have additional functions to implement
}
#+END_SRC

The typeclass equality above allows for types that instantiate it to use its
2 equality function, while the comparison typeclass on the other hand allows for
greater and less than comparison in addition to the equality functions. Additionally 
multiple levels of inheritance can be valid as we can see from the =super_comparison=
typeclass and also multiple inheritance as the =io= typeclass shows.

*** Choosing typeclass instancess for a specific type
An important thing about typeclasses is that types can derive EACH
and every single interface in a different place in the code.
Rationale: Picture you buy the code from someone and you can't change the
implementation and have only the headers and you need to derive some
extra typeclasses without changing the original code.

Another additional concern is on cases where you may want to have a
different instantition of a typeclass changed and swapped even in
runtime. Imagine that there is this typeclass called 'Ordering'
which denotes how the members of a type should be ordered.
Then we have two instances of this typeclass, both implemented by a
type, say a list. One implements an ascending order ordering and the
other a descending order ordering. There should be a way to choose in
runtime which of the two implementations the ordering would use.

So let's look at the following example, which will not compile.
#+BEGIN_SRC refu
instance ordering ord_ascend<vector> {
    fn(self)
    {
        ...
    }
}

instance ordering ord_descend<vector>{
    fn(self)
    {
        ...
    }
}
#+END_SRC
Here we can see an additional feature. Instances of a typeclass can optionally have
an extra identifier if we implement more than one instance of a typeclass for a type.
But why will this not compile? Well simply because 2 different instances
are declared for a type without specifying one as the default implementation for all objects of type vector.
#+BEGIN_SRC C++
instance ordering ord_ascend<vector> = default{
    fn(self)
    {
        ...
    }
}

instance ordering ord_descend<vector>{
    fn(self)
    {
        ...
    }
}
#+END_SRC

With the above code we can declare the =ord_ascend= instance as
default and as such all vector types unless otherwise specified will have
this implementation for the ordering typeclass

And finally below we can see how to change the choice of typeclass instance
in runtime. (TODO)
#+BEGIN_SRC refu
a:list // ord_ascend
b:list<ordering: ord_ascend> // ord_ascend
c:list<ordering: ord_descend> //ord_descend
#+END_SRC

** Thoughts                                                       :noexport:
Links for useful reading:
+ [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.99.8567&rep=rep1&type=pdf][Software Extension and Integration with Type Classes]]
+ [[http://stackoverflow.com/a/6948534/110395][SO answer on difference between typeclasses and interfaces]]
+ [[http://www.artima.com/weblogs/viewpost.jsp?thread=270195][Type parameters versus generics in Scala]]
* Error Handling
** Specification
Error handling is a very serious topic. Refu attempts to make it easy for
the developer to handle all erroneous conditions with ease without
cluttering the implementation of functions. We aim to make it easy to
handle errors and we assume that the execution path in case of an error
is not performance critical since errors are and should always be
extraneous situations.

There are multiple ways to actually handle errors in a function and we
will present them here.
*** Exceptions
  Exceptions can be raised at any point during the code and the stack
  will unwind, calling the deallocators of all objects it encounters
  until a catch is hit.

  #+BEGIN_SRC refu
  fn calculate_square_root(a:double) -> double
  {
      if (a < 0.0) {
           raise // this would raise a generic anonymous exception
           raise negative_double_in_sqrt("Omg noez") // raise a specific exception
      }
      return a*a
   }


   ....
   ....

   try {
       ...
       calculate_square_root(-1.0)

   } catch (e){
       negative_double_in_sqrt =>  do something
       print(e.str)
       _ => {
           print(e.error_str) //the message of the raise
           print(e.location_str) //the location of the raise (function, line_no, file)
       }
}
#+END_SRC

Exceptions can also be derive an exception typeclass. There are some
built-in exception typeclasses defined in the standard library
like std::exceptions::memory, std::exceptions::io and
std::exceptions::numeric. To define an exception as a member of an
exception class the following syntax is used:

#+BEGIN_SRC refu
type negative_in_sqrt {
    msg:string
} derives std::exception<negative_in_sqrt>


...
// then you can throw this type of exception anywhere in the code by
throw negative_in_sqrt("this is an error message")

#+END_SRC
*** Design By Contract
A function can have a contract with its caller. Such contracts are made up
of calling preconditions and calling postconditions. If possible these
checks are performed in compile time, and compiled away for the runtime.
If not they raise an exception in runtime. The user has the option to
completely disable them for a release build.
(Have to think if this should actually happen)
#+BEGIN_SRC refu
fn calculate_square_root(a:double) -> double
:precond(a >= 0.0)
:postcond(result >= 0.0) //not needed, but just here as an example
{
    return a*a;
}
#+END_SRC
** Thoughts                                                       :noexport:
+ (Nice info about [[http://en.wikibooks.org/wiki/Computer_Programming/Error_handling][error handling]] in general and [[http://en.wikibooks.org/wiki/Computer_Programming/Design_by_Contract][Design by contract]] )
+ The way [[http://dlang.org/errors.html][D language handles errors]]

* Modules
** Specification
Programs and libraries written in Refu are divided in modules. A module
can be imported from other parts of code as is, like:
#+BEGIN_SRC refu
import geometry
#+END_SRC

Certain functions, structs or data from modules can also be imported
alone so that the global namespace is not polluted.
#+BEGIN_SRC refu
import vector3d, model from geometry
#+END_SRC

Additionally, imported objects can be given an alias so as to avoid
name conflicts

#+BEGIN_SRC refu
import vector3d, model from geometry as vector_imp, model_imp
#+END_SRC


To encapsulate code into a module one would need to enclose it in
a module block like so:

#+BEGIN_SRC refu
module geometry {
...
...
...
}
#+END_SRC

Modules encompass functionality. In order to allow separation between
private and public module objects there are 2 different ways to arrange
modules. One is as shown above, having all of the module related code
encompassed in a identifier module { ... } block. In that case everything
would be private in the module by default. To mark something as public and
exportable to other modules then you would have to prepend it with the
=export= keyword.

#+BEGIN_SRC refu
module geometry{

    type private_foo{
    ...
    }

    //model will be exported since it has the export attribute
    export type model{
    }

    //this function will be visible from outside the module
    export fn some_public_function(..) ->foo
    {
    }

    //this function will not be visible from outside the module
    fn private_function(..) -> foo
    {
    }

}//end of module
#+END_SRC

Another way to organize modules and by far the preferred way is to
separate a module's signature from its implementation. This allows for
separation of interface from implementation, module typechecking, cleaner
code look and most importantly multiple implementation of module code for
different systems.

As an example consider an IO module that implements I/O functionality for
Linux, Windows, ARM or even javascript!

#+BEGIN_SRC refu
signature io {
    type file; /* definition is in module implementation */

    fn open(name:ref<string>) -> file
    fn read(f:ref<file>) -> bytes
    fn write(f:ref<file>, b:bytes) -> int
}
#+END_SRC

and in two other separate files, the module implementation could be like
this for a different windows and linux implementation.
#+BEGIN_SRC refu
linux_io implof io {
    type file {
        ...
    }

    fn open(name:ref<string>) -> file
    {
        ...
    }
    fn read(f:ref<file>) -> ~bytes
    {
        ...
    }
    fn write(f:ref<file>, b:bytes) -> int
    {
        ...
    }
}
#+END_SRC

#+BEGIN_SRC refu
windows_io implof io {
    type file {
        ...
    }

    fn open(name:ref<string>) -> file
    {
        ...
    }
    fn read(f:ref<file>) -> ~bytes
    {
        ...
    }
    fn write(f:ref<file>, b:bytes) -> int
    {
        ...
    }
}
#+END_SRC
Anything not in the signature of a module is going to be private to a
particular module implementation.

Modules can also accept arguments. Irrespective of the way you declare a
module it can always accept arguments.
- *Signature*
   #+BEGIN_SRC refu
   signature test_module(g:geometry, buffer_size:int = 512) {

       fn do_something()
       fn do_something_with_geometry(t:g::triangle)
       ...

   }

   test implof test_module(g:geometry, buffer_size:int) {
       import g //import the module we passed as argument

       fn do_something()
       {
           allocate_buffer(buffer_size)
       }

       fn do_something_with_geometry(t:g::triangle) -> f32
       {
           return g::calculate_area_of_triangle(t)
       }

   }
   #+END_SRC

- *Without Signature*

  #+BEGIN_SRC refu
  module test_module(g:geometry, buffer_size:int = 512) {
      import g //import the module we passed as argument

       export do_something()
       {
           allocate_buffer(buffer_size)
       }

       export do_something_with_geometry(t:g::triangle) -> f32
       {
           return g::calculate_area_of_triangle(t)
       }
   }
  #+END_SRC

In order to import this from some other place in the code you would do
something like the following:
#+BEGIN_SRC refu
import some_module(my_geometry, 1024)
#+END_SRC

** Thoughts                                                       :noexport:
Where should the modules be searched for? How should linking other libraries
work?
* If expressions
** Specification
In Refu an =if= can act either as an expression or like a statement
depending on the context. That means, that you can assign an if
expression as values to variables. The general if syntax is as follows:

#+BEGIN_SRC refu
if i > 10 {
    increase_a_value()
    compress_a_file()
} elif i < 0 {
    do_something_else()
} else {
    do_last_thing()
}
#+END_SRC

The above =if= acts as a statement since it is not in the right side of
any kind of assignment. But observe below another example usage where =if=
is used as an expression. Depending on the value of =i=, we assign a
specific value to =a=.

#+BEGIN_SRC refu
a:int
a = if i > 10 {
        20
} elif i < 0 {
        40
} else {
        100
}
#+END_SRC

Unlike some other languages the curly braces can't be omitted in any
branch of the if. If the condition of an if branch is complex enough then
it should be enclosed in parentheses like so:

#+BEGIN_SRC refu
if ((i > 10 && i <20) || (x > 30 && x < 40)) {
      do_something()
}
#+END_SRC

* Pattern matching
** Specification
Algebraic data types go hand in hand with the ability to use pattern
matching on those types. This is offered by the match expression keyword
in refu.

Pattern matching is the elimination construct for algebraic data types.
That means that a pattern matching expression, expresses how one should
consume a partciular ADT. For example look below.

#+BEGIN_SRC refu
type list {
nil | load:int, tail:uptr<list>
}

a:list
match a {
     nil   => print("empty list")
     i, _  => print("Head of the list is %d", i)
}
#+END_SRC

Match expressions can also be recursive. A =match()= inside a match expression
renders the whole match recursive. For example look at the matching below
which calculates the length of a list.

#+BEGIN_SRC refu
fn find_length(a:ref<list>) -> int
{
    return match a {
        nil      => 0
        _, tail  => 1 + match(tail)
    }
}
#+END_SRC
For completeness sake it should be noted that the above example can
be written in a simpler way, having the function block omitted:

#+BEGIN_SRC refu
fn find_length(a:ref<list>) -> int
nil      => 0
_, tail  => 1 + find_length(tail)
#+END_SRC

In a =match=, all possible value combinations must be exhausted. =_= means
any value, =nil= means no value and anything else is interpreted as an
identifier to recognize that particular positional argument. Another way
to match something would be depending on the type. For example.

#+BEGIN_SRC refu
type list<T> {
nil | (load:T, tail:uptr<list>)
}

a:list<int> = list<int>(1, 2, 3)
list_type:string = match a {
   nil      => "empty list"
   int, _   => "list of ints"
   _        => "other kind of list"
}
#+END_SRC

From the above, one can notice the following. A match expression is just
that, an expression and can as easily be assigned to something. Also a
match can be on some type with the built-in keyword =typeof=. Finally it
is a compile error to not exhaust all possible matches, so the _ at the
end matches all other cases.

#+BEGIN_SRC refu
type foo {
    a:i16 | b:u16 | c:string | d:bool
}

a:foo
match a {
    string | bool   => "not a number"
    a:(i16 | u16)   => 5 + a
} 
#+END_SRC

Another way to define patterns is by using the type operators. As can be seen above
one can combine possible type reductions using the same operators we use when a
type is defined.

** Thoughts                                                       :noexport:
As very nicely stated on [[http://stackoverflow.com/a/2226292/110395][this SO answer]], pattern matching is the elimination
construct for algebraic data types. That means that a pattern matching
expression, expresses how one should consume a partciular ADT.

* For expressions
** Specification
The simplest way to iterate something in refu is by using a for
expression. The syntax is simple. For a simple iteration of n times one
can use the following.

#+BEGIN_SRC refu
for i in [0..10] {
      do_something(); //this will iterate 11 times, with i ranging from 0 to 10
}
#+END_SRC

There are many ranges that can be covered by a simple for expression.
The simple iteration syntax is =for= /identifier/ =in= /range/. Where
range is a numeric expression within braces of the form
[start .. step .. end].
The step is optional and is shown in the next example.

#+BEGIN_SRC refu
for i in [0..2..10] {
     print(i); //this will print 0, 2, 4, 6, 8, 10
}
#+END_SRC

For expressions are also heavily customizeable on a per type basis.
By deriving the standard library's iterator typeclass you can define
how the expression behave for a specific type. For example:

#+BEGIN_SRC refu
type list {
    nil | payload:int, tail:uptr<list>
}

instance std::iterator<list> {
    fn(self:list)->list
    {
        match(self) {
         (nil) => return Nil
         (val, tail) => return (val, tail)
        }
    }
}

my_list:list = (1, 2, 3, 4, 5)
for i in my_list {
     print(i) //this should print all the values of the list.
}
#+END_SRC

By defining the =list_iter= instance of the iterator typeclass we
just defined the way that lists can be iterated. Afterwards whenever a for
expression is used on a list, the defined implementation is used.
The iterator typeclass looks like this:

#+BEGIN_SRC refu
class iterator<type T> {
     fn(self:ref<T>) -> (nil | (Any, T))
}
#+END_SRC

So, all implementations need to do is define the value at each iteration,
the next object of the iteration and the condition under which the
iteration terminates. The function must return either Nil to denote the
end of the iteration, or a value of type T and the next object for
iteration.

But if you recall the title of the section is for *expressions*. As expressions
they can also be assigned. For example an array can be assigned like this:

#+BEGIN_SRC refu
arr:int[3] = [5, 6, 7]
another_arr:int[] = for i in arr { i + 3 }
#+END_SRC

Afterwards =another_arr= will contain [8, 9, 10]. Of course these
expressions are checked at compile time for validity of type assignment.
If the for block had something that is not an int, or if it had more
statements then it would be a compile error. On the left hand of the
assignment any identifier whose type would agree with =(Nil | int, T)= would
be acceptable.
* Mutability and Immutability
** Specification
All data are by default mutable in Refu. In order to specify mutability
the =const= keyword is used. 

#+BEGIN_SRC refu
type data_record {
    index:int, name:string
}

fn just_read(record:const data_record)
{
    do_something_with_record_index(record.index)
}
#+END_SRC

By defining an object as immutable the compiler can reason about the logic
of the program in a very different way and optimize things away. In addition
it serves as a way to document functions and interfaces between modules to
denote whethen some data can be modified or not.
** Thoughts                                                       :noexport:
The question of immutability is a very interesting one. There are many
examples to be drawn from Scala. [[http://www.scala-lang.org/docu/files/collections-api/collections_12.html][Here]] is a list of mutable and immutable
collections in scala.

Also [[http://docs.scala-lang.org/overviews/collections/overview.html][here]] is a nice piece on the scala docs outlining main differences
on usage of mutable and immutable collections.
* Parallel Processing Framework / Parallel Routines
** Specification
In Refu many small lightweight threads can be spawned. They are called
routines and can be created with the rt keyword.
For example:

#+BEGIN_SRC refu
fn print_some_stuff()
{
   print("eleos")
   print("lol")
}
//run print_some_stuff in another thread
rt print_some_stuff
#+END_SRC

Routines can be communicated to via message passing. ...
More thinking to go here ...TODO
** Thoughts                                                       :noexport:

